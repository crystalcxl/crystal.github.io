---
layout: post
title:  "Kafka-api"
date:   2019-06-12 11:40:18 +0800
categories: BigData
tags: kafka
author: crystalcxl
---

* content
{:toc}

记录下kafka常用api



# ***\*KAFKA-python-API\****

 

***\*1、KafkaProducer\****

 

  ***\*Keyword Arguments:\****

  

***\*1.1\**** ***\*bootstrap_servers\****

' host[:port] '字符串(或' host[:port] '字符串列表)，生产者应联系以引导初始集群元数据。这不必是完整的节点列表。它只需要至少有一个代理来响应元数据API请求。默认端口是9092。如果没有指定服务器，则默认为localhost:9092。

 

***\*1.2\**** ***\*client_id\**** (**str**) 

此客户端的名称。此字符串在每个请求中传递到服务器，可用于标识与此客户机对应的特定服务器端日志条目。默认值:' kafka-python-producer-# '(每个实例都有一个惟一的编号)

 

***\*1.3\**** ***\*key_serializer\**** (**callable**)

用于将用户提供的键(如果没有)转换为字节，称为f(key)，应该返回字节。默认值:None

 

***\*1.4\**** ***\*value_serializer\**** (**callable**)

用于将用户提供的消息值转换为字节。如果不是None，则调用为f(value)，应该返回字节。默认值:None。

 

***\*1.5\**** ***\*acks\**** (**0, 1, 'all'**) 

生产者要求领导者在考虑一个完整的请求之前已经收到的确认的数量。这将控制发送的记录的持久性。以下是常见的设置

***\*0: Producer will not wait for any acknowledgment from the server.\****

消息将立即被添加到套接字缓冲区并被认为已发送。在这种情况下，不能保证服务器已经收到了记录，并且重试配置不会生效(因为客户端通常不会知道任何故障)。每个记录返回的偏移量总是设置为-1。

***\*1: Wait for leader to write the record to its local log only.\****

代理将在未等待所有关注者的完全确认的情况下响应。在这种情况下，如果领导者在确认记录后立即失败，但在追随者复制之前，记录将会丢失。

***\*all: Wait for the full set of in-sync replicas to write the record.\****

这保证了只要至少有一个同步副本仍然存在，记录就不会丢失。这是最有力的保证。

 

如果未设置，默认为acks=1

 

***\*1.6\**** ***\*compression_type\**** (**str**)

生成器生成的所有数据的压缩类型。有效值是' gzip '， ' snappy '， ' lz4 '，或没有。压缩是整批数据的压缩，因此批处理的效果也会影响压缩比(批处理越多越好)

***\*1.7\**** ***\*retries\**** (**int**) 

设置大于零的值将导致客户端重新发送任何发送失败且可能出现暂时错误的记录。请注意，此重试与客户机在接收到错误后重新发送记录没有什么不同。允许重试而不将max_in_flight_requests_per_connection设置为1可能会改变记录的顺序，因为如果将两个批发送到单个分区，第一个失败并重试，但第二个成功，那么第二个批中的记录可能会首先出现。默认值:0

 

***\*1.8\**** ***\*batch_size\**** (**int**)

发送给代理的请求将包含多个批，每个分区有一个可用的数据可供发送。小批处理大小将使批处理不那么常见，并可能降低吞吐量(批处理大小为零将完全禁用批处理)。默认值:16384

 

***\*1.9\**** ***\*linger_ms\**** (**int**) 

生产者将在请求传输之间到达的所有记录分组到单个成批请求中。通常，只有当记录到达的速度快于发送的速度时，才会发生这种情况。但是，在某些情况下，客户机可能希望减少请求的数量，甚至在中等负载下也是如此。该设置通过添加少量人为延迟来实现此目的;也就是说，与立即发送记录不同，生产者将等待给定的延迟，以允许发送其他记录，以便将发送的数据打包在一起。这可以被认为是

 

***\*1.10\**** ***\*partitioner\**** (**callable**)

Callable用于确定每个消息被分配到哪个分区。调用(在密钥序列化之后):分区器(key_bytes, all_partitions, available_partitions)。默认的分区器实现使用与java客户端相同的murmur2算法对每个非空键进行散列，以便将具有相同键的消息分配给相同的分区。当一个键为空时，消息被传递到一个随机分区(如果可能的话，过滤到只有可用的leader的分区)。

 

***\*1.11\**** ***\*buffer_memory\**** (**int**)

生产者应该使用内存的总字节来缓冲等待发送到服务器的记录。如果记录发送的速度比发送到服务器的速度快，那么生产者将阻塞max_block_ms，从而在超时时引发异常。在当前的实现中，这个设置是一个近似值。默认值:33554432 (32 mb)

 

***\*1.12\**** ***\*connections_max_idle_ms\****

在此配置指定的毫秒数之后关闭空闲连接。代理在连接之后关闭空闲连接。这样就避免了在客户机上碰到意外的套接字断开错误。默认值:540000